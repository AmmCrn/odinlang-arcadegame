package code_generation

import "core:fmt"
import "core:strings"
import "core:os"

// delete old code
// also format strings jfc i didnt know you can have multi line ones
// you just do ``
// TODO: decide at compile time whether to use linux or windows function calls

testvar :: `
    asdjklfjdslk
    asfklsajd
`
GFX_PATH :: "gfx/"
INIT_GRAPHICS_PATH :: "src/init_graphics_autogenerated.odin"

main :: proc() {
    generate_graphics_loading()
    if true {
        return
    }
    // file to be generated
    // remove if it exists
    rem_file, rem_file_open_err := os.open(INIT_GRAPHICS_PATH)
    if rem_file_open_err == nil {
        remove_err := os.remove(INIT_GRAPHICS_PATH)
        if(remove_err != nil) {
            fmt.println("error removing file.")
            return
        }
    } else {
        fmt.println("No file exists. Continuing...")
    }
    os.close(rem_file)

    // TODO: this will work for the posix call but maybe not for the windows call?
    // the mode is currently set to -rw-rw-rw-
    file, file_open_err := os.open(INIT_GRAPHICS_PATH, os.O_CREATE, 0o0666)
    if file_open_err != nil {
        fmt.println("error opening file.")
        return
    }
    os.close(file)
    file, file_open_err = os.open(INIT_GRAPHICS_PATH, os.O_RDWR, 0o0666)
    defer os.close(file)

    fmt.println(os.write_string(file, "// AUTO-GENERATED FILE DO NOT EDIT.\npackage main\nimport rl \"vendor:raylib\"\n"))
    os.write_string(file, "load_sprite_map :: proc() -> (smap: map[string]rl.Texture2D, ok: bool) {\n ")
    os.write_string(file, "\tsprmap := make(map[string]rl.Texture2D)\n") // create the sprite map
    os.write_string(file, "\tloadok :bool= true\n")

    // load in the directory and its entries
    dir_handle, open_err := os.open(GFX_PATH)
    if open_err != nil {
        fmt.println("Failed to open gfx directory! err:", open_err)
        return
    }
    defer os.close(dir_handle)

    entries, read_err := os.read_dir(dir_handle, 100, os.heap_allocator())
    if read_err != nil {
        fmt.println("Failed to read gfx directory! err:", read_err)
        return
    }
    defer free_all(os.heap_allocator())

    for entry in entries {
        if !strings.has_suffix(entry.name, ".png"){
            os.file_info_delete(entry)
            continue
        }

        // using strings.clone may be inefficient but it prevents errors caused by file_info_delete
        // maybe fix this in the future?
        sprite_name := entry.name[:len(entry.name) - 4]
        load_str := strings.concatenate({
            "\tsprmap[\"", sprite_name, "\"] = rl.LoadTexture(\"",
            GFX_PATH, entry.name, "\")\n"})
        err_str := strings.concatenate({
            "\tif sprmap[\"", sprite_name, "\"].id == 0 { loadok = false; return sprmap, loadok; }\n"
        })
        os.write_string(file, strings.concatenate({
            load_str, err_str
        }))
        
        os.file_info_delete(entry)
    }

    os.write_string(file, "\n\treturn sprmap, loadok\n}")
}

generate_graphics_loading :: proc() {
    // file to be generated
    // remove if it exists
    rem_file, rem_file_open_err := os.open(INIT_GRAPHICS_PATH)
    if rem_file_open_err == nil {
        remove_err := os.remove(INIT_GRAPHICS_PATH)
        if(remove_err != nil) {
            fmt.println("error removing file.")
            return
        }
    } else {
        fmt.println("No file exists. Continuing...")
    }
    os.close(rem_file)

    // TODO: this will work for the posix call but maybe not for the windows call?
    // the mode is currently set to -rw-rw-rw-
    file, file_open_err := os.open(INIT_GRAPHICS_PATH, os.O_CREATE, 0o0666)
    if file_open_err != nil {
        fmt.println("error opening file.")
        return
    }
    os.close(file)
    file, file_open_err = os.open(INIT_GRAPHICS_PATH, os.O_RDWR, 0o0666)
    defer os.close(file)

    // load in the directory and its entries
    dir_handle, open_err := os.open(GFX_PATH)
    if open_err != nil {
        fmt.println("Failed to open gfx directory! err:", open_err)
        return
    }
    defer os.close(dir_handle)

    entries, read_err := os.read_dir(dir_handle, 100, os.heap_allocator())
    if read_err != nil {
        fmt.println("Failed to read gfx directory! err:", read_err)
        return
    }
    defer free_all(os.heap_allocator())

    builder := strings.builder_make()

    strings.write_string(&builder, "/*\n\tAUTO-GENERATED FILE DO NOT EDIT.\n*/\npackage main\n\nimport rl \"vendor:raylib\"\n\n")
    strings.write_string(&builder, "loadok: bool = true\nGAME_TEXTURE :: enum{\n")

    entry_arr : [dynamic]string
    for entry in entries {
        if !strings.has_suffix(entry.name, ".png"){
            os.file_info_delete(entry)
            fmt.println("WARNING! GFX FOLDER HAS NON-IMAGE FILES. FILE NAME:", entry.name)
            continue
        }

        append(&entry_arr, strings.clone(entry.name[:len(entry.name) - 4])) // remove suffix
        os.file_info_delete(entry)
    }
    for entry in entry_arr {
        strings.write_string(&builder, 
            strings.concatenate({"\t", strings.to_upper(strings.clone(entry)), ",\n"})
        )
    }
    strings.write_string(&builder, "}\n\nload_sprite_map :: proc() -> (sarr: [GAME_TEXTURE]rl.Texture2D, ok: bool) {\n")
    strings.write_string(&builder, "\tspr_arr : [GAME_TEXTURE]rl.Texture2D = {\n")
    // now start loading them into the gpu
    for entry in entry_arr {
        up := strings.to_upper(entry)
        loadstr := strings.concatenate({
            "\t\t.", up,
            " = rl.LoadTexture(\"",
            GFX_PATH, entry, ".png\"),\n"
        })
        strings.write_string(&builder, loadstr)
    }
    strings.write_string(&builder, "\t}\n\n\t// Check for errors\n")
    strings.write_string(&builder, "\tfor tex in spr_arr {\n\t\tif tex.id == 0 { loadok = false; break; }\n\t}")

    strings.write_string(&builder, "\n\treturn spr_arr, loadok\n}")
    os.write_string(file, strings.to_string(builder))
}